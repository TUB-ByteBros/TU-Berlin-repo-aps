<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/WiSe2025-26/IntroProg/2025-10-21/06_Aufgaben/06ex.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WiSe2025-26/IntroProg/2025-10-21/06_Aufgaben/06ex.c" />
              <option name="originalContent" value="/*&#10;Willkommen zum sechsten Aufgabenblatt vom Programmierkurs. Auf diesem Aufabenblatt geht es um enums und structs.&#10;&#10;Um die Tests für dieses Blatt zu kompilieren und zu starten, führen Sie den folgenden Befehl aus:&#10;clang -std=c11 -g -Wall 06ex_test.c -o 06ex_test.o -lm &amp;&amp; ./06ex_test.o&#10;*/&#10;&#10;#include &quot;06_canvas.h&quot;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;math.h&gt;&#10;&#10;/*&#10;In diesem Aufgabenblatt erweitern wir unsere Canvas API um Farben.&#10;Menschen nehmen Farben als Mischung von drei &quot;Basisfarben&quot; wahr: rot, grün, und blau.&#10;Jedes Pixel eines Bildschirms gibt rotes, grünes, und blaues Licht ab, je nach Intensität dieser&#10;drei Farbkanäle sehen wir unterschiedliche Farben.&#10;&#10;Unsere Canvas hat nun neue Funktionen `canvas_set_r`, `canvas_set_g`, and `canvas_set_b`, welche die einzelnen Kanäle&#10;`red`, `green` und `blue` setzen. Das Canvas header-file dokumentiert die neuen Funktionen ausführlicher.&#10;*/&#10;&#10;/*&#10;Aufgabe 1a:&#10;Farben verhalten sich auf einem Bildschirm anders als zum Beispiel Wasserfarben auf Papier.&#10;&#10;Färben Sie die gegebene Canvas so, dass die Rotkomponente jedes Pixels gleichmäßig von ganz links (also bei `x == 0` -&gt; 0.0)&#10;nach ganz rechts (bei `x == maximum` -&gt; 1.0) zunimmt, und die Grünkomponente jedes Pixels gleichmäßig von&#10;ganz unten (also bei `y == 0` -&gt; 0.0) nach ganz oben (bei `y == maximum` -&gt; 1.0) zunimmt.&#10;Die Blaukomponente soll überall unverändert bleiben (und ist nicht in allen Testfällen die selbe).&#10;&#10;Tipp: der Rotanteil für ein Pixel an der X-Koordinate berechnet sich beispielsweise als `x / (Canvasbreite - 1)`.&#10;Aber Vorsicht: bei Division auf `int`s wird immer zur Null abgerundet, während hier z.B. in der Mitte 0.5 rauskommen soll.&#10;(Einen Wert durch den Maximalwert zu teilen um eine Zahl zwischen 0 und 1 zu erhalten, wird als&#10;&quot;normalisieren&quot; bezeichnet. Normalisieren kommt häufig vor, auch auf diesem Blatt. Wie wäre es also mit einer&#10;Hilfsfunktion `float normalize(int value, int max)` ? :-) )&#10;*/&#10;Canvas swatch_red_green(Canvas c) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            float red = (float)x / (canvas_width(c) - 1);&#10;            float green = (float)y / (canvas_height(c) - 1);&#10;            canvas_set_r(c, x, y, red);&#10;            canvas_set_g(c, x, y, green);&#10;        }&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Dieses enum repräsentiert die drei Farbkanäle.&#10;*/&#10;typedef enum ColorChannel_ {&#10;    Red,&#10;    Green,&#10;    Blue&#10;} ColorChannel;&#10;&#10;/*&#10;Aufgabe 1b:&#10;Das obrige Enum können wir nun nutzen um eine Funktion zu schreiben, welche unterschiedliche Farbkanäle setzen kann.&#10;Schreiben Sie die Funktion so, dass der jeweils richtige `channel` des Pixels mit der Koordinate `(x,y)` den Wert `v`&#10;erhält.&#10;*/&#10;Canvas canvas_set_channel(Canvas c, int x, int y, ColorChannel channel, float v) {&#10;    switch (channel) {&#10;        case Red:&#10;            canvas_set_r(c, x, y, v);&#10;            break;&#10;        case Green:&#10;            canvas_set_g(c, x, y, v);&#10;            break;&#10;        case Blue:&#10;            canvas_set_b(c, x, y, v);&#10;            break;&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Aufgabe 1c:&#10;Die folgende Funktion soll eine Canvas nach den selben Richtlinien wie in Aufgabe 1a einfärben, anstelle von Rot für&#10;die X-Achse und Grün für die Y-Achse allerdings die Farben aus den Parametern nutzen.&#10;Schreiben Sie die Funktion so, dass `channel_x` den Farbkanal für die X-Achse festlegt und `channel_y` den Farbkanal für&#10;die Y-Achse.&#10;Alle nicht in den Parametern angegeben Farbkanäle sollen unverändert bleiben.&#10;Setzten Sie _erst_ den Farbkanal `channel_x`, und _danach_ `channel_y`. Bonusdenkaufgabe: in welchen Fällen ist die Reihenfolge relevant?&#10;*/&#10;Canvas swatch_rgb(Canvas c, ColorChannel channel_x, ColorChannel channel_y) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            float value_x = (float)x / (canvas_width(c) - 1);&#10;            float value_y = (float)y / (canvas_height(c) - 1);&#10;            canvas_set_channel(c, x, y, channel_x, value_x);&#10;            canvas_set_channel(c, x, y, channel_y, value_y);&#10;        }&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Häufig wollen wir nicht über einzelne Farbkanäle nachdenken, sondern über Farben als solche.&#10;Darum definieren wir einen neuen Typ für Farben. Eine Farbe wird eindeutig durch die Intensität ihrer drei Farbkanäle&#10;beschrieben, also fassen wir drei Intensitätswerte in einem struct zusammen:&#10;*/&#10;typedef struct RGBByTheWayThisCanBeNamedArbitrarilygSinceWeAreUsingTheTypedefAnyways {&#10;    float r;&#10;    float g;&#10;    float b;&#10;} RGB;&#10;&#10;/*&#10;Aufgabe 2a:&#10;Geben Sie den Wert zurück, der die Farbe Flieder (rot 0.86, grün 0.82, blau 1.0) repräsentiert.&#10;&#10;Hinweis: Häufig werden RGB-Farben alternativ mit Ganzzahlen zwischen 0 und 255 angegeben, statt mit Kommazahlen zwischen 0.0 und 1.0.&#10;Flieder wäre dann z.B. (rot 219, grün 209, blau 255).&#10;*/&#10;RGB lilac() {&#10;    RGB color;&#10;    color.r = 0.85490196f;&#10;    color.g = 0.80784315f;&#10;    color.b = 1.0f;&#10;    return color;&#10;}&#10;&#10;/*&#10;Aufgabe 2b:&#10;Nutzen wir nun unser neues struct auf der Canvas. Die folgende Funktion soll mit einem Funktionsaufruf alle&#10;Kanäle gleichzeitig ansteuern!&#10;Setzen Sie die Farbe des Pixels mit Koordinate `(x, y)` auf die von `color` repräsentierte Farbe.&#10;*/&#10;Canvas canvas_set_rgb_struct(Canvas c, int x, int y, RGB color) {&#10;    canvas_set_r(c, x, y, color.r);&#10;    canvas_set_g(c, x, y, color.g);&#10;    canvas_set_b(c, x, y, color.b);&#10;    return c;&#10;}&#10;&#10;/*&#10;Aufgabe 2c:&#10;Konvertieren Sie die gegebene Farbe in den Grauton der gleichen Helligkeit.&#10;Die Helligkeit vom Grauton berechnet sich, indem man den Rotwert mit 0.2989, den Grünwert mit 0.587,&#10;und den Blauwert mit 0.1140 multipliziert, und die Resultate addiert.&#10;Der Grauton mit dieser Helligkeit setzt alle drei Farbkanäle auf diesen Wert.&#10;*/&#10;RGB rgb_to_gray(RGB color) {&#10;    float gray = color.r * 0.2989f + color.g * 0.587f + color.b * 0.1140f;&#10;    color.r = gray;&#10;    color.g = gray;&#10;    color.b = gray;&#10;    return color;&#10;}&#10;&#10;/*&#10;Aufgabe 2d:&#10;Konvertieren Sie mithilfe der `rgb_to_gray` Funktion das gegebene Bild in ein Graustufenbild.&#10;Die aktuelle Farbe eines Pixels kann mit den `canvas_get_r`, `canvas_get_g` und `canvas_get_b` Funktionen ausgelesen&#10;werden (siehe Headerfile für die Dokumentation).&#10;&#10;Tipp: Genau so wie wir die drei Funktionen zum Färben zusammengefasst haben ließen sich auch die gerade genannten drei&#10;Funktionen in einer Hilfsfunktion zusammenfassen welche die Farbe an der gegebenen Koordinate als ein&#10;Wert vom Typ `RGB` zurück gibt.&#10;*/&#10;Canvas canvas_to_gray(Canvas c) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            RGB color;&#10;            color.r = canvas_get_r(c, x, y);&#10;            color.g = canvas_get_g(c, x, y);&#10;            color.b = canvas_get_b(c, x, y);&#10;            RGB gray_color = rgb_to_gray(color);&#10;            canvas_set_rgb_struct(c, x, y, gray_color);&#10;        }&#10;    }&#10;    return c;&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10;Willkommen zum sechsten Aufgabenblatt vom Programmierkurs. Auf diesem Aufabenblatt geht es um enums und structs.&#10;&#10;Um die Tests für dieses Blatt zu kompilieren und zu starten, führen Sie den folgenden Befehl aus:&#10;clang -std=c11 -g -Wall 06ex_test.c -o 06ex_test.o -lm &amp;&amp; ./06ex_test.o&#10;*/&#10;&#10;#include &quot;06_canvas.h&quot;&#10;#include &lt;stdio.h&gt;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;math.h&gt;&#10;&#10;/*&#10;In diesem Aufgabenblatt erweitern wir unsere Canvas API um Farben.&#10;Menschen nehmen Farben als Mischung von drei &quot;Basisfarben&quot; wahr: rot, grün, und blau.&#10;Jedes Pixel eines Bildschirms gibt rotes, grünes, und blaues Licht ab, je nach Intensität dieser&#10;drei Farbkanäle sehen wir unterschiedliche Farben.&#10;&#10;Unsere Canvas hat nun neue Funktionen `canvas_set_r`, `canvas_set_g`, and `canvas_set_b`, welche die einzelnen Kanäle&#10;`red`, `green` und `blue` setzen. Das Canvas header-file dokumentiert die neuen Funktionen ausführlicher.&#10;*/&#10;&#10;/*&#10;Aufgabe 1a:&#10;Farben verhalten sich auf einem Bildschirm anders als zum Beispiel Wasserfarben auf Papier.&#10;&#10;Färben Sie die gegebene Canvas so, dass die Rotkomponente jedes Pixels gleichmäßig von ganz links (also bei `x == 0` -&gt; 0.0)&#10;nach ganz rechts (bei `x == maximum` -&gt; 1.0) zunimmt, und die Grünkomponente jedes Pixels gleichmäßig von&#10;ganz unten (also bei `y == 0` -&gt; 0.0) nach ganz oben (bei `y == maximum` -&gt; 1.0) zunimmt.&#10;Die Blaukomponente soll überall unverändert bleiben (und ist nicht in allen Testfällen die selbe).&#10;&#10;Tipp: der Rotanteil für ein Pixel an der X-Koordinate berechnet sich beispielsweise als `x / (Canvasbreite - 1)`.&#10;Aber Vorsicht: bei Division auf `int`s wird immer zur Null abgerundet, während hier z.B. in der Mitte 0.5 rauskommen soll.&#10;(Einen Wert durch den Maximalwert zu teilen um eine Zahl zwischen 0 und 1 zu erhalten, wird als&#10;&quot;normalisieren&quot; bezeichnet. Normalisieren kommt häufig vor, auch auf diesem Blatt. Wie wäre es also mit einer&#10;Hilfsfunktion `float normalize(int value, int max)` ? :-) )&#10;*/&#10;Canvas swatch_red_green(Canvas c) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            float red = (float)x / (canvas_width(c) - 1);&#10;            float green = (float)y / (canvas_height(c) - 1);&#10;            canvas_set_r(c, x, y, red);&#10;            canvas_set_g(c, x, y, green);&#10;        }&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Dieses enum repräsentiert die drei Farbkanäle.&#10;*/&#10;typedef enum ColorChannel_ {&#10;    Red,&#10;    Green,&#10;    Blue&#10;} ColorChannel;&#10;&#10;/*&#10;Aufgabe 1b:&#10;Das obrige Enum können wir nun nutzen um eine Funktion zu schreiben, welche unterschiedliche Farbkanäle setzen kann.&#10;Schreiben Sie die Funktion so, dass der jeweils richtige `channel` des Pixels mit der Koordinate `(x,y)` den Wert `v`&#10;erhält.&#10;*/&#10;Canvas canvas_set_channel(Canvas c, int x, int y, ColorChannel channel, float v) {&#10;    switch (channel) {&#10;        case Red:&#10;            canvas_set_r(c, x, y, v);&#10;            break;&#10;        case Green:&#10;            canvas_set_g(c, x, y, v);&#10;            break;&#10;        case Blue:&#10;            canvas_set_b(c, x, y, v);&#10;            break;&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Aufgabe 1c:&#10;Die folgende Funktion soll eine Canvas nach den selben Richtlinien wie in Aufgabe 1a einfärben, anstelle von Rot für&#10;die X-Achse und Grün für die Y-Achse allerdings die Farben aus den Parametern nutzen.&#10;Schreiben Sie die Funktion so, dass `channel_x` den Farbkanal für die X-Achse festlegt und `channel_y` den Farbkanal für&#10;die Y-Achse.&#10;Alle nicht in den Parametern angegeben Farbkanäle sollen unverändert bleiben.&#10;Setzten Sie _erst_ den Farbkanal `channel_x`, und _danach_ `channel_y`. Bonusdenkaufgabe: in welchen Fällen ist die Reihenfolge relevant?&#10;*/&#10;Canvas swatch_rgb(Canvas c, ColorChannel channel_x, ColorChannel channel_y) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            float value_x = (float)x / (canvas_width(c) - 1);&#10;            float value_y = (float)y / (canvas_height(c) - 1);&#10;            canvas_set_channel(c, x, y, channel_x, value_x);&#10;            canvas_set_channel(c, x, y, channel_y, value_y);&#10;        }&#10;    }&#10;    return c;&#10;}&#10;&#10;/*&#10;Häufig wollen wir nicht über einzelne Farbkanäle nachdenken, sondern über Farben als solche.&#10;Darum definieren wir einen neuen Typ für Farben. Eine Farbe wird eindeutig durch die Intensität ihrer drei Farbkanäle&#10;beschrieben, also fassen wir drei Intensitätswerte in einem struct zusammen:&#10;*/&#10;typedef struct RGBByTheWayThisCanBeNamedArbitrarilygSinceWeAreUsingTheTypedefAnyways {&#10;    float r;&#10;    float g;&#10;    float b;&#10;} RGB;&#10;&#10;/*&#10;Aufgabe 2a:&#10;Geben Sie den Wert zurück, der die Farbe Flieder (rot 0.86, grün 0.82, blau 1.0) repräsentiert.&#10;&#10;Hinweis: Häufig werden RGB-Farben alternativ mit Ganzzahlen zwischen 0 und 255 angegeben, statt mit Kommazahlen zwischen 0.0 und 1.0.&#10;Flieder wäre dann z.B. (rot 219, grün 209, blau 255).&#10;*/&#10;RGB lilac() {&#10;    RGB color;&#10;    color.r = 0.85490196f;&#10;    color.g = 0.80784315f;&#10;    color.b = 1.0f;&#10;    return color;&#10;}&#10;&#10;/*&#10;Aufgabe 2b:&#10;Nutzen wir nun unser neues struct auf der Canvas. Die folgende Funktion soll mit einem Funktionsaufruf alle&#10;Kanäle gleichzeitig ansteuern!&#10;Setzen Sie die Farbe des Pixels mit Koordinate `(x, y)` auf die von `color` repräsentierte Farbe.&#10;*/&#10;Canvas canvas_set_rgb_struct(Canvas c, int x, int y, RGB color) {&#10;    canvas_set_r(c, x, y, color.r);&#10;    canvas_set_g(c, x, y, color.g);&#10;    canvas_set_b(c, x, y, color.b);&#10;    return c;&#10;}&#10;&#10;/*&#10;Aufgabe 2c:&#10;Konvertieren Sie die gegebene Farbe in den Grauton der gleichen Helligkeit.&#10;Die Helligkeit vom Grauton berechnet sich, indem man den Rotwert mit 0.2989, den Grünwert mit 0.587,&#10;und den Blauwert mit 0.1140 multipliziert, und die Resultate addiert.&#10;Der Grauton mit dieser Helligkeit setzt alle drei Farbkanäle auf diesen Wert.&#10;*/&#10;RGB rgb_to_gray(RGB color) {&#10;    float gray = color.r * 0.2989f + color.g * 0.587f + color.b * 0.1140f;&#10;    color.r = gray;&#10;    color.g = gray;&#10;    color.b = gray;&#10;    return color;&#10;}&#10;&#10;/*&#10;Aufgabe 2d:&#10;Konvertieren Sie mithilfe der `rgb_to_gray` Funktion das gegebene Bild in ein Graustufenbild.&#10;Die aktuelle Farbe eines Pixels kann mit den `canvas_get_r`, `canvas_get_g` und `canvas_get_b` Funktionen ausgelesen&#10;werden (siehe Headerfile für die Dokumentation).&#10;&#10;Tipp: Genau so wie wir die drei Funktionen zum Färben zusammengefasst haben ließen sich auch die gerade genannten drei&#10;Funktionen in einer Hilfsfunktion zusammenfassen welche die Farbe an der gegebenen Koordinate als ein&#10;Wert vom Typ `RGB` zurück gibt.&#10;*/&#10;Canvas canvas_to_gray(Canvas c) {&#10;    for (int y = 0; y &lt; canvas_height(c); y++) {&#10;        for (int x = 0; x &lt; canvas_width(c); x++) {&#10;            RGB color;&#10;            color.r = canvas_get_r(c, x, y);&#10;            color.g = canvas_get_g(c, x, y);&#10;            color.b = canvas_get_b(c, x, y);&#10;            RGB gray_color = rgb_to_gray(color);&#10;            canvas_set_rgb_struct(c, x, y, gray_color);&#10;        }&#10;    }&#10;    return c;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>